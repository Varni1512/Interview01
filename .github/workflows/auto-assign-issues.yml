# Name of the workflow
name: Automatic Issue Assignment and Labeling

# Events that trigger the workflow
on:
  issues:
    types: [opened, reopened]
  workflow_dispatch:

# Permissions required for the workflow
permissions:
  issues: write

jobs:
  auto-assign-and-label:
    if: github.event_name == 'issues'
    runs-on: ubuntu-latest
    steps:
      - name: Assign the issue and add labels
        uses: actions/github-script@v6
        with:
          script: |
            const issueNumber = context.issue.number;
            const issueCreator = context.payload.issue.user.login;

            // Get current labels
            const { data: currentLabels } = await github.rest.issues.listLabelsOnIssue({
              owner: context.repo.owner,
              repo: context.repo.repo,
              issue_number: issueNumber
            });
            const labelNames = currentLabels.map(l => l.name);

            // Assign if not already assigned
            const isAssigned = context.payload.issue.assignees && context.payload.issue.assignees.length > 0;
            if (!isAssigned) {
              console.log(`Assigning issue #${issueNumber} to ${issueCreator}.`);
              await github.rest.issues.addAssignees({
                owner: context.repo.owner,
                repo: context.repo.repo,
                issue_number: issueNumber,
                assignees: [issueCreator]
              });
            } else {
              console.log(`Issue #${issueNumber} is already assigned.`);
            }

            // Add comment if not already present
            await github.rest.issues.createComment({
              owner: context.repo.owner,
              repo: context.repo.repo,
              issue_number: issueNumber,
              body: `Hello @${issueCreator}! This issue has been assigned to you.`
            });

            // Labels to ensure
            const requiredLabels = ['assigned', 'gssoc2025', 'gssoc', 'gssoc25'];
            const labelsToAdd = requiredLabels.filter(l => !labelNames.includes(l));

            if (labelsToAdd.length > 0) {
              console.log(`Adding labels: ${labelsToAdd.join(', ')} to issue #${issueNumber}.`);
              await github.rest.issues.addLabels({
                owner: context.repo.owner,
                repo: context.repo.repo,
                issue_number: issueNumber,
                labels: labelsToAdd
              });
            } else {
              console.log(`All required labels already present for issue #${issueNumber}.`);
            }

  process-old-issues:
    if: github.event_name == 'workflow_dispatch'
    runs-on: ubuntu-latest
    steps:
      - name: Process old and unassigned issues
        uses: actions/github-script@v6
        with:
          script: |
            const owner = context.repo.owner;
            const repo = context.repo.repo;

            console.log('Looking for old and unassigned issues...');
            const { data: issues } = await github.rest.issues.listForRepo({
              owner,
              repo,
              state: 'open',
              per_page: 100
            });

            const requiredLabels = ['assigned', 'gssoc2025', 'gssoc', 'gssoc25'];

            for (const issue of issues) {
              const issueNumber = issue.number;
              const issueCreator = issue.user.login;

              // Current labels
              const labelNames = issue.labels.map(l => l.name);
              const labelsToAdd = requiredLabels.filter(l => !labelNames.includes(l));

              // Assign if not already assigned
              const isAssigned = issue.assignees && issue.assignees.length > 0;
              if (!isAssigned) {
                try {
                  await github.rest.issues.addAssignees({
                    owner,
                    repo,
                    issue_number: issueNumber,
                    assignees: [issueCreator]
                  });
                  console.log(`Issue #${issueNumber} assigned to ${issueCreator}.`);
                } catch (error) {
                  console.error(`Error assigning issue #${issueNumber}: ${error.message}`);
                }
              } else {
                console.log(`Issue #${issueNumber} is already assigned.`);
              }

              // Add comment
              try {
                await github.rest.issues.createComment({
                  owner,
                  repo,
                  issue_number: issueNumber,
                  body: `Hello @${issueCreator}! This issue has been assigned to you.`
                });
                console.log(`Comment added to issue #${issueNumber}.`);
              } catch (error) {
                console.error(`Error adding comment to issue #${issueNumber}: ${error.message}`);
              }

              // Add missing labels
              if (labelsToAdd.length > 0) {
                try {
                  await github.rest.issues.addLabels({
                    owner,
                    repo,
                    issue_number: issueNumber,
                    labels: labelsToAdd
                  });
                  console.log(`Added missing labels: ${labelsToAdd.join(', ')} to issue #${issueNumber}.`);
                } catch (error) {
                  console.error(`Error adding labels to issue #${issueNumber}: ${error.message}`);
                }
              } else {
                console.log(`All required labels already present for issue #${issueNumber}.`);
              }
            }
            console.log('Finished processing old issues.');
